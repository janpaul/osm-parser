import { open, stat } from "fs/promises"
import { inflateSync } from "zlib"
import { BlobHeader, Blob } from "./proto/fileformat_pb.js"
import { HeaderBlock, PrimitiveBlock } from "./proto/osmformat_pb.js"
import { toNetworkByteOrder } from "./lib"
import type { MyKeysValues, MyNode, MySimpleNode, MyWay, MyRelation } from "./types"
import { MyRelationNode } from "./types"

const [, , , inputFile] = process.argv
console.log(`parsing ${inputFile}`)

const textDecoder = new TextDecoder()

const getFilesizeInBytes = async (filename: string): Promise<number> => {
  const { size } = await stat(filename)
  return size
}
const getBlobData = (blob: Blob): Buffer => {
  let blobData
  if (blob.getRaw()) {
    // console.log("Blob contains data")
    blobData = blob.getRaw()
  } else {
    const zdata = blob.getZlibData()
    // console.log(`Blob contains zlib data of ${zdata.length} bytes`)
    blobData = inflateSync(zdata)
  }
  // test if the data matches the expected but don't do anything with it
  if (blobData.length === blob.getRawSize()) {
    // console.log("blob data matches expected length")
  } else {
    console.error("Blob data does NOT match expected length")
  }
  return blobData
}

const extractKeysVals = (data: number[], stringTable: string[]): MyKeysValues[] => {
  const keysVals: MyKeysValues[] = []
  let current: MyKeysValues = {}
  let index = 0
  while (index < data.length) {
    const number = data[index]
    if (number === 0) {
      keysVals.push(current)
      current = {}
      index++
    } else {
      const key = stringTable[number]
      const val = stringTable[number + 1]
      index += 2
      current[key] = val
    }
  }
  return keysVals
}

const mergeKeysVals = (keys: string[], vals: string[]): MyKeysValues => {
  const keysVals: MyKeysValues = {}
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i]
    keysVals[key] = vals[i]
  }
  return keysVals
}

const parseStringTable = (block: PrimitiveBlock): string[] =>
  block
    .getStringtable()
    .getSList()
    .map((data) => {
      if (data instanceof String) {
        return data
      } else {
        return textDecoder.decode(data as Uint8Array)
      }
    }) as string[]

type NodeCallback = (arg0: MyNode) => void
type WayCallback = (arg0: MyWay) => void
type RelationCallback = (arg0: MyRelation) => void

const main = async (onNode: NodeCallback, iDidIt?: WayCallback, onRelation?: RelationCallback) => {
  const fileSize = await getFilesizeInBytes(inputFile)
  const f = await open(inputFile, "r")
  let bytesRead = 0
  const blockNodes: Record<number, MySimpleNode> = {}
  const blockWays: Record<number, MyWay> = {}
  const blockRelations: Record<number, MyRelation> = {}

  while (bytesRead < fileSize) {
    console.log(`*** starting new Blob`)

    // the first 4 bytes contain the length of the BlobHeader
    const blength = new Uint8Array(4)
    await f.read(blength, 0, 4)
    bytesRead += 4
    const blobHeaderSize = toNetworkByteOrder(blength)

    // using the length of the blob header, grab the blob header
    const bblobHeader = new Uint8Array(blobHeaderSize)
    bytesRead += blobHeaderSize
    await f.read(bblobHeader, 0, blobHeaderSize)
    const blobHeader = BlobHeader.deserializeBinary(bblobHeader)
    const dataSize = blobHeader.getDatasize()

    // the Blob is `dataSize` bytes in length. Go and grab it.
    const bblob = new Uint8Array(dataSize)
    bytesRead += dataSize
    await f.read(bblob, 0, dataSize)
    const blob = Blob.deserializeBinary(bblob)
    const blobData = getBlobData(blob)

    // depending on the type of the blobHeader, parse the data.
    if (blobHeader.getType() === "OSMHeader") {
      // console.log("parsing HeaderBlock")
      const headerBlock = HeaderBlock.deserializeBinary(blobData)
      console.log(`this osm.pbf was generated by ${headerBlock.getWritingprogram()}`)

      // console.log(`listing required features:`)
      // const rfeatures = headerBlock.getRequiredFeaturesList()
      // for (const feature of rfeatures) {
      //   console.log(`  ${feature}`)
      // }
      //
      // console.log(`listing optional features:`)
      // const ofeatures = headerBlock.getOptionalFeaturesList()
      // for (const feature of ofeatures) {
      //   console.log(`  ${feature}`)
      // }
    }
    if (blobHeader.getType() === "OSMData") {
      console.log(`  *** starting new PrimitiveBlock`)
      const primitiveBlock = PrimitiveBlock.deserializeBinary(blobData)
      const stringTable = parseStringTable(primitiveBlock)
      const granularity = primitiveBlock.getGranularity()
      const latOffset = primitiveBlock.getLatOffset()
      const lonOffset = primitiveBlock.getLonOffset()
      const dateGranularity = primitiveBlock.getDateGranularity()
      const calculateLatitude = (v: number): number => 0.000000001 * (latOffset + granularity * v)
      const calculateLongitude = (v: number): number => 0.000000001 * (lonOffset + granularity * v)
      const calculateDate = (v: number): number => v * dateGranularity

      for (const primitiveGroup of primitiveBlock.getPrimitivegroupList()) {
        console.log(`     *** starting new PrimitiveGroup`)
        const dense = primitiveGroup.getDense()
        const nodes = primitiveGroup.getNodesList()
        const ways = primitiveGroup.getWaysList()
        const relations = primitiveGroup.getRelationsList()
        if (nodes && nodes.length > 0) {
          // console.log(`parsing ${nodes.length} nodes`)
        }
        if (dense && dense.getIdList().length > 0) {
          console.log(`parsing dense nodes`)
          const ids = dense.getIdList()
          const lats = dense.getLatList()
          const lons = dense.getLonList()
          const keysVals = extractKeysVals(dense.getKeysValsList(), stringTable)
          // console.log({ ids: ids.length, lats: lats.length, lons: lons.length, keysVals: keysVals.length })
          let id = 0,
            lat = 0,
            lon = 0 // these are delta encoded
          for (let i = 0; i < ids.length; i++) {
            id += ids[i]
            lat += lats[i]
            lon += lons[i]
            const elat = calculateLatitude(lat)
            const elon = calculateLongitude(lon)
            const snode: MySimpleNode = { id, lat: elat, lon: elon }
            blockNodes[id] = snode
            const node: MyNode = { ...snode, kv: keysVals[i] }
            onNode(node)
            // console.log(`DENSENODE=cached nodes:`, Object.keys(blockNodes).length)
          }
        }
        if (ways && ways.length > 0) {
          console.log(`parsing ${ways.length} ways in group`)
          // console.log(`WAYS=cached nodes:`, Object.keys(blockNodes).length)
          for (const way of ways) {
            let ref = 0
            const refs = way.getRefsList()
            const nodeRefs: MySimpleNode[] = []
            for (let i = 0; i < refs.length; i++) {
              ref += refs[i]
              // console.log({ ref, node: blockNodes[ref] })
              nodeRefs.push(blockNodes[ref])
            }
            const keys = way.getKeysList().map((i) => stringTable[i])
            const vals = way.getValsList().map((i) => stringTable[i])
            // console.log({ refs: refs.length, keys: keys.length, vals: vals.length })
            const myWay: MyWay = { id: way.getId(), refs: nodeRefs, kv: mergeKeysVals(keys, vals) }
            blockWays[way.getId()] = myWay
            iDidIt && iDidIt(myWay)
          }
        }
        if (relations && relations.length > 0) {
          console.log(`parsing ${relations.length} relations in group from ${Object.keys(blockNodes).length} nodes`)
          for (const relation of relations) {
            const keys = relation.getKeysList().map((i) => stringTable[i])
            const vals = relation.getValsList().map((i) => stringTable[i])
            const roles = relation.getRolesSidList().map((i) => stringTable[i])
            const members = relation.getMemidsList()
            const types = relation.getTypesList()
            let member = 0
            let wayId = 0
            // console.log({ roles: roles.length, members: members.length, types: types.length })
            const _nodes: MyRelationNode[] = []
            for (let i = 0; i < roles.length; i++) {
              const role = roles[i]
              const type = types[i]
              member += members[i]
              // console.log({ role, s: stringTable[role] })
              switch (type) {
                case 0: {
                  const node = blockNodes[member]
                  // console.log(node ? { node, role } : `node ${member} not found (role=${role})`)
                  if (node) {
                    _nodes.push({ ...node, role })
                  }
                  break
                }
                case 1: {
                  const way = blockWays[member]
                  // console.log(way ? { way } : `way ${member} not found`)
                  if (way) {
                    for (const ref of way.refs) {
                      _nodes.push({ ...ref, role })
                    }
                  }
                  break
                }
                case 2: {
                  const other = blockRelations[member]
                  if (other) {
                    for (const node of other.nodes) {
                      _nodes.push({ ...node, role })
                    }
                  }
                  // console.log(other ? { other } : `relation ${member} not found`)
                  break
                }
              }
            }
            const myRelation: MyRelation = {
              id: relation.getId(),
              kv: mergeKeysVals(keys, vals),
              nodes: _nodes,
            }
            blockRelations[relation.getId()] = myRelation
            onRelation && onRelation(myRelation)
          }
        }
      }
    }
  }
}

const onNode: NodeCallback = (node: MyNode) => {
  console.log({ id: node.id, lat: node.lat, lon: node.lon, kv: node.kv })
}
const onWay: WayCallback = (way: MyWay) => {
  // console.log(`got way ${way.id}`)
}
const onRelation: RelationCallback = (relation: MyRelation) => {
  // console.log(`got relation ${relation.id} with ${relation.nodes.length} nodes`)
}
main(onNode).then(() => console.log("Done"))
